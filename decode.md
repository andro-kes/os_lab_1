Загрузка/инициализация программы
731 execve("./build/prime_checker", ...) = 0
— запущен бинарник.
Последующие brk/mmap/openat/read/fstat/mmap/arch_prctl/… — загрузка динамических библиотек (libc), настройка адресного пространства. Это загрузчик/рантайм, обычно в отчёте упоминается кратко: «загружены libc и т.п.».
Промпт ввода файла
731 write(1</dev/pts/0>, "Enter input filename:\n", 22) = 22
— программа печатает приглашение на stdout.

731 read(0pipe:[490900], "numbers.txt\n", 256) = 12
— программа читает имя файла из stdin; в вашем запуске вы подавали "numbers.txt\n" через конвейер (printf/echo), поэтому read получает 12 байт.

Создание пайпов
731 pipe2([3pipe:[490256], 4pipe:[490256]], 0) = 0
731 pipe2([5pipe:[490257], 6pipe:[490257]], 0) = 0
Два пайпа созданы (так и в коде): первый — parent → child, второй — child → parent. По номерам FD можно восстановить, кто что закрывает и кто использует:

pipe [490256] — fds 3 (read) и 4 (write)
pipe [490257] — fds 5 (read) and 6 (write)
После fork каждый процесс закроет неиспользуемые концы:

Родитель закрыл read-энд первого пайпа и write-энд второго: в логе видно
731 close(3pipe:[490256]) = 0 (родитель закрыл 3)
731 close(6pipe:[490257]) = 0 (родитель закрыл 6) => следовательно, родитель будет ПИСАТЬ в fd 4 (parent→child) и ЧИТАТЬ из fd 5 (child→parent).
Дочерний процесс закрыл write-энд первого пайпа и read-энд второго:
732 close(4pipe:[490256]) = 0 (child закрыл 4)
732 close(5pipe:[490257]) = 0 (child закрыл 5) => следовательно, child будет ЧИТАТЬ из fd 3 и ПИСАТЬ в fd 6.
Итого:

parent → child: parent пишет в fd 4, child читает из fd 3.
child → parent: child пишет в fd 6, parent читает из fd 5.
Открытие файлов
731 openat(..., "numbers.txt", O_RDONLY) = 3</workspaces/lab1/numbers.txt>
— родитель открыл входной файл (fd 3 at that moment).
731 openat(..., "output.txt", O_WRONLY|O_CREAT|O_TRUNC, 0644) = 6</workspaces/lab1/output.txt>
— родитель открыл/создал output.txt (fd 6).
(Нумерация fd в логе может пересекаться с fd-ами пайпов — но смысл такой: родитель читает входной файл и пишет в пайп, затем читает ответы из пайпа и пишет в output.txt.)

Родитель читает файл и отправляет в пайп
731 read(3</workspaces/lab1/numbers.txt>, "...", 1024) = 57
— прочитаны 57 байт из numbers.txt (весь файл).
731 write(4pipe:[490256], "...", 57) = 57
— родитель единовременно записал содержимое файла в pipe (в сторону дочернего процесса).
Это соответствует коду: родитель читает файл чанком и пишет в pipe_parent_to_child[1].

Как дочерний процесс обрабатывает данные (посимвольно) Дальше видим много мелких read/write уже помеченных PID 732 (child) и 731 (parent) — это обмен по пайпу и запись в output.txt:
732 read(3pipe:[490256], "4", 1) = 1
— child читает по одному символу.

Когда child досчитывает до конца строки (buf == '\n' или '\r'), он обрабатывает строку и делает write в свой write-FD (6):

732 write(6pipe:[490257], "Number ", 7) = 7
732 write(6pipe:[490257], "4", 1) = 1
732 write(6pipe:[490257], " - composite.\n", 14) = 14
Родитель читает эти сообщения из fd 5 (read-end child→parent) и сразу пишет их в output.txt:

731 read(5pipe:[490257], "Number ", 1024) = 7
731 write(6</workspaces/lab1/output.txt>, "Number ", 7) = 7
далее аналогично для цифры и строки статуса.
Таким образом child формирует сообщения по кусочкам: сначала "Number ", потом цифры, потом " - composite.\n". Parent читает их (возможно в других размерах) и складывает в output.txt.

Обработка строки с буквами ("aaa")
Для строки "aaa" child вызывает:
732 write(6pipe:[490257], "Skipping invalid line: '", 24) = 24
732 write(6pipe:[490257], "aaa", 3) = 3
732 write(6pipe:[490257], "'\n", 2) = 2 — т.е. child определил, что строка не число, и отправил сообщение «Skipping invalid line: 'aaa'».
Окончание: обнаружение простого числа и завершение
Для числа 17 дочерний процесс обнаруживает, что оно простое, и пишет:
732 write(6pipe:[490257], " - prime or negative. Terminating.\n", 35) = 35
Затем child вызывает exit_group/_exit:
732 exit_group(0 <unfinished ...>), затем +++ exited with 0 +++
Родитель получает SIGCHLD:
731 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=732, ...} ---
Родитель дочитывает оставшиеся данные (read(5, "", 1024) = 0) — EOF на pipe от child, закрывает свои дескрипторы:
731 close(5pipe:[490257]) = 0
731 close(6</workspaces/lab1/output.txt>) = 0
И делает wait4(732, NULL, 0, NULL) = 732 — дождался завершения child.
Наконец, parent делает exit_group(0) и завершает выполнение.